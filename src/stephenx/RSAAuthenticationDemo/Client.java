package stephenx.RSAAuthenticationDemo;

import java.net.*;
import java.io.*;
import java.util.*;
import java.math.BigInteger;
import java.security.*;
import java.security.cert.*;
import java.security.interfaces.RSAPublicKey;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;

/**
 * <p>The TCP client using RSA and TEA encryption.</p>
 * 
 * @author Stephen Xie &lt;***@andrew.cmu.edu&gt;
 */
public class Client {
    
    private static String serverIP;
    private static Scanner input = new Scanner(System.in);
    
    // server's public key using RSA
    private static BigInteger n;  // the shared modulus
    private static BigInteger e;  // the exponent of the public key
    
    // information of the RSA public key
    private static final String certLoc = "stephenx_cert.cer";  // location to the certificate generated by Java's keytool
    

    /**
     * Main driver that sends a given message to the server.
     * 
     * @param args 
     */
    public static void main (String args[]) {
        loadPublicKey();
        Socket s = null;
        serverIP = "localhost";
        try {
            int serverPort = 7896;  // the listening port of the server
            s = new Socket(serverIP, serverPort);
            
            DataOutputStream out =new DataOutputStream(s.getOutputStream());
            
            // generate symmetric key for TEA
            byte[] symmetricKey = generateTEAKey();
            // encrypt the key using server's public key then send to server
            out.write(RSA.encrypt(symmetricKey, n, e));
            out.flush();

            // construct the request JSON string
            TEA crypto = new TEA(symmetricKey);
            String request = constructReq();
            byte[] encryptedReq = crypto.encrypt(request.getBytes());
            out.write(encryptedReq);  // write the string to the server
            out.flush();
            
            // read feedback from the server
            // the server will close the socket instantly if invalid symmetric
            // key detected, and an exception will be thrown on the client.
            // Here it will just throw an EOF exception, as the server closed
            // socket early without providing feedback
            DataInputStream in = new DataInputStream(s.getInputStream());
            String response = in.readUTF();
            System.out.println(response);
            
        } catch (UnknownHostException e) {
            System.out.println("Socket: " + e.getMessage());
            
        } catch (EOFException e) {
            System.out.println("EOF: server has closed the communication channel.");
            
        } catch (IOException e) {
            System.out.println("readline: " + e.getMessage());
            
        } finally {
            if (s != null)
                try {
                    s.close();
                } catch (IOException e) {
                    System.out.println("close: " + e.getMessage());
                }
        }
    }
    
    
    /**
     * Load public key from the X509 certificate.
     */
    private static void loadPublicKey() {
        try (
                FileInputStream certFile = new FileInputStream(certLoc);
                BufferedInputStream ksbufin = new BufferedInputStream(certFile)
            ) {
            X509Certificate cert = (X509Certificate)
                    CertificateFactory.getInstance("X.509").generateCertificate(ksbufin);
            
            // read the public key
            RSAPublicKey publicKey = (RSAPublicKey)cert.getPublicKey();
            e = publicKey.getPublicExponent();
            n = publicKey.getModulus();
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    
    /**
     * Generate a symmetric 128-bit key for TEA.
     * @return the TEA key as a byte array (or null if an exception is thrown)
     */
    private static byte[] generateTEAKey() {
        byte[] result = null;
        // generate a random 16-byte key
        SecureRandom rand = new SecureRandom();
        byte[] key;
        do {
            // SecureRandom could generate bytes that represent negative
            // BigIntegers; ensure key is positive
            key = rand.generateSeed(16);

        } while (new BigInteger(key).compareTo(BigInteger.ZERO) <= 0);

        result = key;
        
        return result;
    }
    
    
    /**
     * Reads from user and constructs the unencrypted request JSON string to be
     * sent to the server.
     * 
     * @return a JSON string to be encrypted
     */
    private static String constructReq() {
        
        System.out.print("Enter your ID: ");
        String userID = input.nextLine();
        
        System.out.print("Enter your password: ");
        String pass = input.nextLine();
        
        System.out.print("Enter secret message (keep it empty if you're not the Chief!): ");
        String secret = input.nextLine();
        
        // construct and return JSON string using Gson
        JsonObject req = new JsonObject();
        req.addProperty("ID", userID);
        req.addProperty("password", pass);
        req.addProperty("secret", secret);
        
        Gson gson = new GsonBuilder().create();
        
        return gson.toJson(req);
    }
    
}
