package stephenx.RSAAuthenticationDemo;

import java.net.*;
import java.io.*;
import java.util.*;
import com.google.gson.*;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.security.*;
import java.security.interfaces.*;

/**
 * <p>The TCP server using RSA and TEA encryption.</p>
 * 
 * @author Stephen Xie &lt;***@andrew.cmu.edu&gt;
 */
public class Server {
    
    private static Map<String, Users> clients;
    private static int connectionCount;
    // used to check if all characters in the decrypted request are ASCII chars
    private static final CharsetEncoder ASCII = Charset.forName("US-ASCII").newEncoder();
    
    // server's private key using RSA
    private static BigInteger n;  // the shared modulus
    private static BigInteger d;  // the exponent of the private key
    
    // information of the RSA private key
    private static final String keystoreLoc = "stephenx_keystore.jks";  // location to the keystore generated by Java's keytool
    private static final String password = "Stephen";
    private static final String alias = "StephenX";
    
    
    public static void main (String args[]) {
        // initialize server state
        loadUsers();
        loadPrivateKey();
        connectionCount = 0;
        
        try{
            int serverPort = 7896;  // the server port
            ServerSocket listenSocket = new ServerSocket(serverPort);
            
            System.out.println("Waiting for clients to visit...");
                
            while (true) {  // keep accepting requests
                Socket clientSocket = listenSocket.accept();
                Connection c = new Connection(clientSocket);
            }
        } catch (IOException e) {
            System.out.println("Listen socket:"+e.getMessage());
        }
    }
    
    /**
     * Load private key from the keystore file.
     */
    private static void loadPrivateKey() {
        try (
                FileInputStream fis = new FileInputStream(keystoreLoc)
            ) {
            KeyStore keyStore = KeyStore.getInstance("JKS");
            keyStore.load(fis, password.toCharArray());
            
            // read the private key
            RSAPrivateKey privateKey = (RSAPrivateKey)keyStore.getKey(alias,password.toCharArray());
            
            d = privateKey.getPrivateExponent();
            n = privateKey.getModulus();
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    /**
     * <p>Load user profiles.</p>
     * <p>Note: password salts and hashes can be generated using PasswordHash.</p>
     */
    private static void loadUsers() {
        clients = new HashMap<>();
        clients.put("Moe", new Users("Moe", "sIBS4sAEtW1BsrP3n6MUEIhklOvXBR39KP+/VkkHWGM=", "Q9Ea4KVsCTuGlufRWslEpWZFin7VckaifE0UHYR7uRg=", "Chief Software Engineer"));
        clients.put("Larry", new Users("Larry", "IR2hlK56ml+dqGsluRlq4A7m85P1NcXCDLKkixIGxYU=", "8ivDGDYHLvaaybZJCkWhO7bWZcXYQ+dKeVR/zIwUhwc=", "Associate Software Engineer"));
        clients.put("Shemp", new Users("Shemp", "HqZbNqKH7ZBS3N5wbZX36TVITlWCVHI/mS2VpSRD1wY=", "VvyuctW+ginnh746CK1/bCw9fsX5sioRucMGxvUgmyw=", "Associate Software Engineer"));
    }
    
    
    // the class that handles connection details
    private static class Connection extends Thread {
        private DataInputStream in;
        private DataOutputStream out;
        private Socket clientSocket;

        public Connection (Socket aClientSocket) {
            try {
                clientSocket = aClientSocket;
                in = new DataInputStream(clientSocket.getInputStream());
                out =new DataOutputStream(clientSocket.getOutputStream());
                
                this.start();
                
            } catch (IOException e) {
                System.out.println("Connection: " + e.getMessage());
            }
        }

        public void run() {
            try {
                // get TEA key from client and construct TEA crypto
                byte[] data = new byte[1000];
                int numberOfBytes = in.read(data);  // read a line of data from the stream
                TEA crypto = getCrypto(Arrays.copyOfRange(data, 0, numberOfBytes));
                
                // TODO: the following screen prompt is not optimized for concurrent requests
                
                System.out.printf("Got visit %d: ", ++connectionCount);
                numberOfBytes = in.read(data);  // read a line of data from the stream
                byte[] decryptedRequest = crypto.decrypt(Arrays.copyOfRange(data, 0, numberOfBytes));
                String request = new String(decryptedRequest);
                
                // check if symmetric key is valid by evaluating if all characters of the decrypted
                // request string is in ASCII
                if (ASCII.canEncode(request)) {
                    // request format: {"ID":"xxx","password":"xxx","secret":"xxx",...}

                    // get the main json object from parsing the request string
                    JsonObject jsonObj = new JsonParser().parse(request).getAsJsonObject();
                    // then get ID and password
                    String username = jsonObj.get("ID").getAsString();
                    String password = jsonObj.get("password").getAsString();

                    // evaluate user identity
                    if (clients.containsKey(username) && clients.get(username).isPasswordValid(password)) {
                        String secret = jsonObj.get("secret").getAsString();

                        // when user tries to send secrets: check if he / she is the Chief
                        if (!secret.isEmpty()) {
                            if (clients.get(username).isChief()) {
                                System.out.printf("%s, %s; a secret message is sent to server.\n",
                                        username, clients.get(username).getTitle());

                            } else {
                                System.out.printf("Unauthorized user %s attempted to send secret message to server.\n", username);
                                out.writeUTF("You are not allowed to send secrets. Please contact your chief software engineer.");
                                out.flush();
                                return;
                            }
                        } else {  // just a normal access
                            System.out.printf("%s, %s.\n", username, clients.get(username).getTitle());
                        }

                        // write feedback to client
                        out.writeUTF("Thank you. Your info was securely transmitted to the server.");
                        out.flush();

                    } else {  // user authentication info is not valid
                        System.out.printf("Illegal password attempt on account %s.\n", username);
                        out.writeUTF("Illegal ID or password.");
                        out.flush();
                    }
                } else {  // symmetric key is not valid
                    System.out.println("Illegal symmetric key used. This may be an attack!");
                    // the server instantly close the socket and doesn't deal
                    // with illegal symmetric keys at all; uncomment the following
                    // code if you'd like to send something to the client
                    // out.writeUTF("Illegal symmetric key.");
                    // out.flush();
                }
            } catch (EOFException e) {
                System.out.println("EOF: "+e.getMessage());
            } catch (IOException e) {
                System.out.println("readline: "+e.getMessage());
            } catch (Exception e) {
                System.out.println("Client sent in corrupted data.");
            } finally {
                try {
                    clientSocket.close();
                } catch (IOException e) {
                    /* close failed */
                    e.printStackTrace();
                }
            }
        }
        
        /**
         * Decrypt the symmetric key from client and return a constructed TEA crypto.
         * @param encrypted the encrypted key
         * @return TEA crypto with the decrypted key
         */
        private static TEA getCrypto(byte[] encrypted) {
            byte[] decryptedKey = RSA.decrypt(encrypted, n, d);
            return new TEA(decryptedKey);
        }
        
    }
}


class Users {
    private String userID;
    private String hashedPass;
    private String salt;
    private String title;
    private boolean isChief;  // is this the Chief Software Engineer?
    
    /**
     * Constructor.
     * @param userID user ID
     * @param passwd password
     * @param title job title
     */
    public Users(String userID, String hashedPass, String salt, String title) {
        this.userID = userID;
        this.hashedPass = hashedPass;
        this.salt = salt;
        this.title = title;
        this.isChief = title.equals("Chief Software Engineer");
        // for now, I'll just use the job title to determine if this is the admin
    }
    
    /**
     * Evaluate if the password matches record.
     * @param password the password to be tested
     * @return a boolean value indicating if the password matches record
     */
    public boolean isPasswordValid(String password) {
        return PasswordHash.generateHash(password, salt).equals(hashedPass);
    }
    
    /**
     * Get the title of this user.
     * @return the user's job title
     */
    public String getTitle() {
        return title;
    }
    
    /**
     * Check if this is the Chief.
     * @return a boolean value indicating if this is the chief
     */
    public boolean isChief() {
        return isChief;
    }
}
